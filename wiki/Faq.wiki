#summary Frequently asked questions

= Flash-VideoIO FAQ =

== Is Flash application a good choice for VoIP? ==
Please see my blog article [http://p2p-sip.blogspot.com/2010/02/faq-on-using-flash-player-to-make-phone.html FAQ on using Flash player to make phone calls] for answers to these questions:

  # Is Flash application a good choice for VoIP?
  # Will there be any performance degradation when the call goes through the following paths? (Flash Client -> Media Server ->RTMP to SIP Converter -> VOIP Server -> VoIP/PSTN Gateway -> PSTN Network -> Telephone)
  # Some experts says that the development in C or C++ is prefered for VOIP call to phone instead of Flash Player for performance reason. Is that true?
  # There are different media servers available. like Adobe Flash Media server (FMS), Wowza, Red5 etc. Which one is the best choice?
  # We are now in a confusion whether to develop our VOIP application in Flash technology or QT/Java/C#. What will be your choice?

== Does it support RTMP? What about RTMFP? ==

Yes, it supports both RTMP (client-server media path) and RTMFP (peer-to-peer media path). Most of the tutorial deals with RTMP. If you set the `src` property to appropriate "rtmfp" URL and set `farID` to appropriate value before setting `play`, then it enables RTMFP mode for peer-to-peer media. Please visit [http://myprojectguide.org/p/flash-videoio/9.html How to do peer-to-peer video call?] for details. Also some example applications such as iChatNow, Random-Face and Public-Chat listed on the [http://code.google.com/p/flash-videoio project page] use RTMFP using Adobe Stratus service.

== Does it support web-to-phone calls and vice-versa? ==

Yes, partially. It supports Flash-to-SIP calls and vice-versa using an external SIP-RTMP gateway such [http://code.google.com/p/siprtmp/ siprtmp.py]. You can use the extensive Javascript API to build your own web phone user interface including call control and a dial-pad for sending in-call DTMF digits. You _need_ to use your own PSTN termination provider that can terminate your SIP calls and translate to PSTN, and vice-versa. Please see [http://myprojectguide.org/p/flash-videoio/11.html How to do SIP-based VoIP calls?] for details. In summary, your termination provider must support Speex voice codec, and understand SIP, SDP and RTP.

== Can I use it to build a video call application on Facebook using FBML? ==

Yes. Please see the [http://apps.facebook.com/face-talk Face Talk] application. Facebook's FBML mangles Javascript. Due to this the API used to interact between Flash Player and Javascript breaks. A friend of mine and I worked on a making Flash VideoIO compatible with Facebook.

== How do I embed it in another Flex application? ==

Starting with version 1.5, I have added support in VideoIO so that you can embed it in your another Flex application using SWFLoader. The VideoIO.swf detects that if it is the top level application then it enables ExternalInterface based communication with Javascript, otherwise it allows your top-level Flex/ActionScript application code to communicate with it directly using similar method and event names as the Javascript API. Until I formally document the API, you can see the example MXML application code for [http://myprojectguide.org/p/flash-videoio/flex-embed.mxml.txt Flex Builder 3/SDK 3] or [http://myprojectguide.org/p/flash-videoio/flex4-embed.mxml.txt Flash Builder 4/SDK 4]. Since VideoIO is compiled with Flex Builder 3/SDK 3, it works very well if your application also uses SDK version 3. There are some compatibility issues if your application uses Flash Builder 4/SDK 4, e.g., with respect to the sizes of control bar and buttons, and event dispatched by VideoIO to application.

== How do I implement text chat? ==

All our existing applications use external signaling channel such as websocket or channel API to implement any text chat messaging. Please see the example source code in SVN for details.

If you wish to do the text chat within VideoIO without external mechanism: In the client-server case you can use call method and onCallback callback to implement a server mediated text chat within RTMP. In the group communication case you can use the post method and onPostingNotify callback to implement the group text message. In version 2.6 we added a new API, sendData method and onReceiveData callback that allows sending some text data in a publishing stream which is received by all playing stream. 

To test this feature, use a local RTMP server, open two windows with [http://myprojectguide.org/p/flash-videoio/test.html test.html] page, set "src" property to `rtmp://localhost/myapp?publish=live` in first and `rtmp://localhost/myapp?play=live` in second, to enable streaming from first to second. Then in the first browser, in the call input box of bottom right corner, type `sendData('this is some text')` and press enter. In the second browser, you should see the onReceivedData callback with this text in the text area box. Note that the sendData can only be called from publishing VideoIO and onReceivedData is only invoked on playing VideoIO side.

This feature can be used for both client-server and P2P RTMFP communication to implement text chat as follows. Suppose in a two-party call, if user A has video1 and video2 for publish and play respectively, and user B has video3 and video4 for publish and play, then user A can send message by calling getFlashMovie("video1").sendData("some text message") and on user B's side onReceiveData(event) callback is invoked which has event.data as "some text message" and event.objectID as "video4". When user B wants to send a text message it uses getFlashMovie("video3").sendData("another message") and on user A's side onReceiveData(event) callback will have event.objectID as "video2".

The API description is as follows until it appears on the tutorial pages. The "sendData" method can be used to send some text in a publishing stream to all the other subscribed playing streams. This is particularly useful for P2P RTMFP mode using Stratus service where you cannot use the call() method and implement a server side feature, but you need an end-to-end text/data transfer mechanism.Unlike the post() method that works in a group, the sendData() method is useful for client-server and peer-to-peer streams. The other end receives a onReceiveData(data) callback method invoked when it receives the sendData command in the stream. For a one-to-many stream, the publishers calls sendData and all the players receive onReceiveData callback. You can call sendData only if VideoIO is publishing, and will get onReceiveData only if VideoIO is playing. It is up to the application to define the meaning of the text data send and received via this method.

== How do I implement picture-in-picture mode? ==
The picture-in-picture mode is not planned to be explicitly implemented in VideoIO.swf because we believe you can achieve the same effect by embedding VideoIO in another Flash application or in HTML.

We created an [http://myprojectguide.org/p/flash-videoio/pip.html pip.html] and [http://myprojectguide.org/p/flash-videoio/VideoPIP.html VideoPIP.html] to test out this feature. You need to use Flash Player 10.3 or later, and use rtmplite's rtmp.py server for a quick test. You can view the source and incorporate similar code in your HTML or Flex application for picture-in-picture mode.

For embedding in HTML as shown in pip.html there are certain restrictions e.g., the minimum dimension of VideoIO must be 215x138 and full-screen mode is for each VideoIO. To avoid these restrictions you can embed the two VideoIO.swf in another Flash application as shown in VideoPIP.html.

== How do I use H.264 encoder? ==
Flash Player 11 (beta) comes with H.264/Avc encoder, whereas the decoder is available in Flash Player 9 or later. Flash-videoIO 2.4 or later supports H.264 encoding. Please make sure to use VideoIO11.swf that is compiled for target player version 11. If you use the [http://myprojectguide.org/p/flash-videoio/test.html test.html] page, it automatically detects your Flash Player version and uses the correct VideoIO. You can right click on the video box to see the Flash Player version. On Chrome browser which comes with a built-in Flash Player, even if you install player version 11, it will prefer to use the built-in version. To change this open "about:plugins" from your Chrome address bar, click on "Details" on top right, and disable the built-in Flash Player that came with Chrome, so that your other installed Flash Player is used. Once on the test.html page, change the "videoCodec" property to `H264Avc` and press enter. The value must be exactly `H264Avc` and not alternatives such as `H264/Avc` or `H.264Avc`. Then start a locally running RTMP server, and set the "src" property to `rtmp://localhost/call/123?publish=live` and press enter to start publishing in H.264. Open another tab in your browser and visit the same test page. Set the "src" property to `rtmp://localhost/call/123?play=live` and press enter to start playing the stream published by the previous tab. You can see noticeable difference in the quality of the video played. In particular, the blockiness of the video disappears when using H.264. If you enable "cameraLoopback" property on the publishing side, you will still see blockiness of the video; perhaps Flash Player still displays the local loopback video using Sorenson, but sends using H.264 on network when the video codec is set to H.264. Try setting "cameraQuality" property to 80 and press enter for a reasonably good quality value.